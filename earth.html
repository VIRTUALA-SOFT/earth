<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ULULATO – Earth 3D</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#050b15; font-family:system-ui, sans-serif; overflow: hidden; }
    #app { display:flex; height:100%; width: 100%; }
    
    #ui { 
      width:280px; 
      padding:20px; 
      color:#f5f5f5; 
      box-sizing:border-box; 
      background: rgba(5, 11, 21, 0.95); 
      border-right: 1px solid #333;
      z-index: 10;
      display: flex; flex-direction: column;
    }
    
    #globe { flex:1; position: relative; }
    h2 { margin-top: 0; font-size: 1.2rem; margin-bottom: 20px; color: #ffd966; }
    label { font-size: 0.9rem; margin-bottom: 8px; display: block; }
    select { 
      width:100%; padding:10px; background: #1a2639; color: white; border: 1px solid #444; border-radius: 4px; outline: none;
    }
    select:hover { border-color: #ffd966; }

    #loader {
      position: absolute; top: 0; left: 0; right: 0; bottom: 0;
      background: #050b15; color: #ffd966;
      display: flex; justify-content: center; align-items: center;
      font-size: 1.5rem; z-index: 100; transition: opacity 0.5s ease;
    }
  </style>
</head>
<body>

<div id="loader">Cargando Planeta...</div>

<div id="app">
  <div id="ui">
    <h2>ULULATO – Pueblos de origen</h2>
    <label for="puebloSelect">Selecciona un pueblo:</label>
    <select id="puebloSelect">
      <option value="">-- Rotación Libre --</option>
      <option value="arhuaco">Arhuaco (Sierra Nevada)</option>
      <option value="wayuu">Wayuu (La Guajira)</option>
      <option value="embera">Emberá (Chocó/Antioquia)</option>
    </select>
    <div style="margin-top: auto; font-size: 0.8rem; color: #666;">
      <p>Click en los puntos para navegar.</p>
    </div>
  </div>
  <div id="globe"></div>
</div>

<script type="module">
  // Usamos CDN directo para evitar errores de módulos
  import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
  import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

  // DATOS
  const pueblos = {
    arhuaco: { name:"Arhuaco", lat:10.85, lon:-73.7, url:"/ululato/arhuaco" },
    wayuu:   { name:"Wayuu",   lat:11.8,  lon:-72.9, url:"/ululato/wayuu" },
    embera:  { name:"Emberá",  lat:6.0,   lon:-76.0, url:"/ululato/embera" }
  };

  const container = document.getElementById("globe");
  const loaderDiv = document.getElementById("loader");

  // ESCENA
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x050b15);
  
  const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
  camera.position.set(0, 0, 6.5);

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  container.appendChild(renderer.domElement);

  // LUCES
  scene.add(new THREE.AmbientLight(0xffffff, 0.3));
  const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
  sunLight.position.set(5, 3, 5);
  scene.add(sunLight);
  const backLight = new THREE.DirectionalLight(0x445566, 0.5);
  backLight.position.set(-5, -3, -10);
  scene.add(backLight);

  // GESTOR DE CARGA
  const loadingManager = new THREE.LoadingManager();
  loadingManager.onLoad = () => {
    loaderDiv.style.opacity = '0';
    setTimeout(() => { loaderDiv.style.display = 'none'; }, 500);
  };
  const textureLoader = new THREE.TextureLoader(loadingManager);

  // --- TIERRA ---
  const earthGroup = new THREE.Group();
  scene.add(earthGroup);

  // CORRECCIÓN 1: Nombres exactos (Case Sensitive)
  const earthMap    = textureLoader.load("textures/8k_earth_daymap.jpg"); 
  const normalMap   = textureLoader.load("textures/Earth-normal-8k.png");
  // CORRECCIÓN DE ERROR 404: 'EarthSpec.png' con mayúsculas como en tu GitHub
  const specMap     = textureLoader.load("textures/EarthSpec.png"); 

  const earthGeo = new THREE.SphereGeometry(2, 64, 64);
  const earthMat = new THREE.MeshPhongMaterial({
    map: earthMap,
    normalMap: normalMap,
    normalScale: new THREE.Vector2(0.5, 0.5),
    specularMap: specMap,
    specular: new THREE.Color(0x333333),
    shininess: 15
  });
  const earth = new THREE.Mesh(earthGeo, earthMat);
  earthGroup.add(earth);

  // PUNTOS
  const spotGroup = new THREE.Group();
  earth.add(spotGroup);

  function latLonToVector3(lat, lon, radius) {
    const phi   = (90 - lat) * (Math.PI / 180);
    const theta = (lon + 180) * (Math.PI / 180);
    const x = -(radius * Math.sin(phi) * Math.cos(theta));
    const z = (radius * Math.sin(phi) * Math.sin(theta));
    const y = (radius * Math.cos(phi));
    return new THREE.Vector3(x, y, z);
  }

  const spotGeo = new THREE.SphereGeometry(0.035, 16, 16);
  const spotMat = new THREE.MeshBasicMaterial({ color: 0xffd966 });

  Object.entries(pueblos).forEach(([key, p]) => {
    const mesh = new THREE.Mesh(spotGeo, spotMat);
    const pos = latLonToVector3(p.lat, p.lon, 2.005); 
    mesh.position.copy(pos);
    mesh.userData = { puebloId: key, url: p.url };
    
    // Anillo
    const ringGeo = new THREE.RingGeometry(0.05, 0.065, 32);
    const ringMat = new THREE.MeshBasicMaterial({ color: 0xffd966, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.position.copy(pos);
    ring.lookAt(new THREE.Vector3(0,0,0));
    spotGroup.add(mesh);
    spotGroup.add(ring);
  });

  // CONTROLES
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enablePan = false;
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.minDistance = 3;
  controls.maxDistance = 10;
  
  // CORRECCIÓN: Limitar ángulo polar evita que la tierra se invierta (bug de Antártida)
  controls.minPolarAngle = 0.5; // No ver el polo norte puro
  controls.maxPolarAngle = 2.5; // No ver el polo sur puro

  // RAYCASTER
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  renderer.domElement.addEventListener("click", (e) => {
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const hits = raycaster.intersectObjects(spotGroup.children);
    if (hits.length > 0) {
      const hit = hits.find(h => h.object.userData.puebloId);
      if (hit) {
        window.location.href = hit.object.userData.url; 
      }
    }
  });

  // ANIMACIÓN
  let isAutoRotating = true;
  let isFocusing = false; 

  function animate() {
    requestAnimationFrame(animate);
    const time = performance.now() * 0.001;
    spotGroup.children.forEach((obj, i) => {
      if (obj.geometry.type === 'RingGeometry') {
        const s = 1 + 0.3 * Math.sin(time * 3 + i);
        obj.scale.set(s, s, s);
      }
    });

    if (isAutoRotating && !isFocusing) {
      earthGroup.rotation.y += 0.0005; 
    }
    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  // --- SELECCIÓN Y GIRO ---
  const select = document.getElementById("puebloSelect");

  select.addEventListener("change", (e) => {
    const id = e.target.value;
    if (!id) {
      isAutoRotating = true;
      return;
    }
    const p = pueblos[id];
    if (p) focusPueblo(p);
  });

  function focusPueblo(p) {
    isAutoRotating = false;
    isFocusing = true;
    
    // CORRECCIÓN 2: Calibración matemática exacta
    const latRad = p.lat * (Math.PI / 180);
    const lonRad = p.lon * (Math.PI / 180);

    // Ajuste de Offset (Longitud)
    // "Math.PI / 2" (90 grados) suele ser el estándar, pero si se ve a la izquierda,
    // necesitamos rotar un poco más la esfera.
    const targetY = -lonRad + (Math.PI / 2); 

    // Ajuste de Tilt (Latitud)
    // latRad positivo debe inclinar la esfera hacia el frente
    const targetX = latRad;

    // Lógica para encontrar el giro más corto (evita vueltas locas)
    const currentY = earthGroup.rotation.y % (Math.PI * 2);
    earthGroup.rotation.y = currentY;
    let diffY = targetY - currentY;
    if (diffY > Math.PI) diffY -= Math.PI * 2;
    if (diffY < -Math.PI) diffY += Math.PI * 2;
    const finalY = currentY + diffY;

    // Reseteamos rotación X suavemente también
    const startX = earthGroup.rotation.x;
    
    const duration = 1500;
    const startTime = performance.now();

    function tween() {
      const now = performance.now();
      const progress = Math.min(1, (now - startTime) / duration);
      // Easing suave
      const ease = progress < 0.5 ? 4 * progress * progress * progress : 1 - Math.pow(-2 * progress + 2, 3) / 2;

      earthGroup.rotation.y = currentY + (finalY - currentY) * ease;
      earthGroup.rotation.x = startX + (targetX - startX) * ease;

      if (progress < 1) {
        requestAnimationFrame(tween);
      } else {
        isFocusing = false;
      }
    }
    tween();
  }

  window.addEventListener("resize", () => {
    const w = container.clientWidth;
    const h = container.clientHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
  });
</script>
</body>
</html>
