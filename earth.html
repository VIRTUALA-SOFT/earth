<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ULULATO – Earth 3D</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#050b15; font-family:system-ui, sans-serif; overflow: hidden; }
    #app { display:flex; height:100%; width: 100%; }
    
    /* Panel lateral */
    #ui { 
      width:280px; 
      padding:20px; 
      color:#f5f5f5; 
      box-sizing:border-box; 
      background: rgba(5, 11, 21, 0.95); 
      border-right: 1px solid #333;
      z-index: 10;
      display: flex;
      flex-direction: column;
    }
    
    #globe { flex:1; position: relative; }
    
    h2 { margin-top: 0; font-size: 1.2rem; margin-bottom: 20px; color: #ffd966; }
    label { font-size: 0.9rem; margin-bottom: 8px; display: block; }
    select { 
      width:100%; 
      padding:10px; 
      background: #1a2639; 
      color: white; 
      border: 1px solid #444; 
      border-radius: 4px; 
      outline: none;
    }
    select:hover { border-color: #ffd966; }

    /* Pantalla de carga */
    #loader {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #050b15;
      color: #ffd966;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 1.5rem;
      z-index: 100;
      transition: opacity 0.5s ease;
    }
  </style>
</head>
<body>

<!-- Pantalla de Carga -->
<div id="loader">Cargando Texturas 8K...</div>

<div id="app">
  <div id="ui">
    <h2>ULULATO – Pueblos de origen</h2>
    <label for="puebloSelect">Selecciona un pueblo:</label>
    <select id="puebloSelect">
      <option value="">-- Rotación Libre --</option>
      <option value="arhuaco">Arhuaco (Sierra Nevada)</option>
      <option value="wayuu">Wayuu (La Guajira)</option>
      <option value="embera">Emberá (Chocó/Antioquia)</option>
    </select>
    
    <div style="margin-top: auto; font-size: 0.8rem; color: #666;">
      <p>Usa el mouse para rotar y hacer zoom.</p>
    </div>
  </div>
  <div id="globe"></div>
</div>

<!-- Importmap para versiones modernas (opcional pero recomendado) -->
<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

  // 1. CONFIGURACIÓN DE DATOS
  const pueblos = {
    arhuaco: { name:"Arhuaco", lat:10.85, lon:-73.7, url:"/ululato/arhuaco" },
    wayuu:   { name:"Wayuu",   lat:11.8,  lon:-72.9, url:"/ululato/wayuu" },
    embera:  { name:"Emberá",  lat:6.0,   lon:-76.0, url:"/ululato/embera" }
  };

  const container = document.getElementById("globe");
  const loaderDiv = document.getElementById("loader");

  // 2. ESCENA BÁSICA
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x050b15); // Fondo espacio oscuro

  const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
  camera.position.set(0, 0, 6.5); // Un poco más lejos para ver bien

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Optimización retina
  container.appendChild(renderer.domElement);

  // 3. ILUMINACIÓN
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
  scene.add(ambientLight);

  const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
  sunLight.position.set(5, 3, 5);
  scene.add(sunLight);

  // Luz de rebote (rim light) para que se vea bonito el borde oscuro
  const backLight = new THREE.DirectionalLight(0x445566, 0.5);
  backLight.position.set(-5, -3, -10);
  scene.add(backLight);

  // 4. GESTOR DE CARGA (Loading Manager)
  const loadingManager = new THREE.LoadingManager();
  
  loadingManager.onLoad = () => {
    // Cuando todo cargue, ocultamos el loader
    loaderDiv.style.opacity = '0';
    setTimeout(() => { loaderDiv.style.display = 'none'; }, 500);
  };

  const textureLoader = new THREE.TextureLoader(loadingManager);

  // 5. LA TIERRA
  // NOTA: Asegúrate de que las rutas sean correctas en tu servidor
  const earthGroup = new THREE.Group();
  scene.add(earthGroup);

  // Usamos texturas. Si fallan las rutas locales, fallará la carga.
  // Asegúrate de que la carpeta 'textures' esté junto al html.
  const earthMap    = textureLoader.load("textures/8k_earth_daymap.jpg");
  const normalMap   = textureLoader.load("textures/Earth-normal-8k.png");
  const specMap     = textureLoader.load("textures/EarthSpec.png");

  const earthGeo = new THREE.SphereGeometry(2, 64, 64);
  const earthMat = new THREE.MeshPhongMaterial({
    map: earthMap,
    normalMap: normalMap,        // CORREGIDO: antes decía normalpMap
    normalScale: new THREE.Vector2(0.5, 0.5), // CORREGIDO: Vector2 requerido
    specularMap: specMap,
    specular: new THREE.Color(0x333333),
    shininess: 15
  });
  
  const earth = new THREE.Mesh(earthGeo, earthMat);
  earthGroup.add(earth);

  // Atmósfera simple (brillo externo)
  const atmosGeo = new THREE.SphereGeometry(2.03, 64, 64);
  const atmosMat = new THREE.MeshPhongMaterial({
    color: 0x00aaff,
    transparent: true,
    opacity: 0.1,
    side: THREE.BackSide,
    blending: THREE.AdditiveBlending
  });
  const atmosphere = new THREE.Mesh(atmosGeo, atmosMat);
  earthGroup.add(atmosphere);


  // 6. PUNTOS (MARCADORES)
  const spotGroup = new THREE.Group();
  earth.add(spotGroup); // Añadimos al mesh de la tierra para que roten con ella

  // Función para convertir Lat/Lon a Vector3 en la superficie de la esfera
  function latLonToVector3(lat, lon, radius) {
    const phi   = (90 - lat) * (Math.PI / 180);
    const theta = (lon + 180) * (Math.PI / 180);

    // Three.js coord system: Y is up.
    // Mapeo estándar esférico:
    const x = -(radius * Math.sin(phi) * Math.cos(theta));
    const z = (radius * Math.sin(phi) * Math.sin(theta));
    const y = (radius * Math.cos(phi));

    return new THREE.Vector3(x, y, z);
  }

  const spotGeo = new THREE.SphereGeometry(0.035, 16, 16);
  const spotMat = new THREE.MeshBasicMaterial({ color: 0xffd966 });

  Object.entries(pueblos).forEach(([key, p]) => {
    const mesh = new THREE.Mesh(spotGeo, spotMat);
    // Un poquito más de 2.0 para que no atraviese la textura
    const pos = latLonToVector3(p.lat, p.lon, 2.005); 
    mesh.position.copy(pos);
    mesh.userData = { puebloId: key, url: p.url };
    
    // Anillo exterior para resaltar
    const ringGeo = new THREE.RingGeometry(0.05, 0.06, 32);
    const ringMat = new THREE.MeshBasicMaterial({ color: 0xffd966, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.position.copy(pos);
    ring.lookAt(new THREE.Vector3(0,0,0)); // Orientar hacia el centro
    
    spotGroup.add(mesh);
    spotGroup.add(ring);
  });

  // 7. INTERACCIÓN Y CONTROLES
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enablePan = false;
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.minDistance = 3;
  controls.maxDistance = 10;

  controls.minPolarAngle = 0.5; // No ver el polo norte puro
  controls.maxPolarAngle = 2.5; // No ver el polo sur puro

  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  // Click evento
  renderer.domElement.addEventListener("click", (e) => {
    // Si estamos arrastrando (moviendo cámara), no activar click
    // Una forma simple de evitar clicks falsos al rotar es medir el tiempo de mousedown/up
    // pero aquí usaremos lógica directa del raycaster.
    
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    // Intersectamos con spotGroup.children
    const hits = raycaster.intersectObjects(spotGroup.children);

    if (hits.length > 0) {
      // Buscamos el objeto que tenga userData (porque el anillo no tiene ID)
      const hit = hits.find(h => h.object.userData.puebloId);
      if (hit) {
        const url = hit.object.userData.url;
        console.log("Navegando a:", url);
        // Descomenta la siguiente línea para navegar de verdad:
        // window.location.href = url;
        alert(`Navegar a: ${url}`);
      }
    }
  });

  // 8. ANIMACIÓN Y GIRO AUTOMÁTICO
  let isAutoRotating = true;
  let targetRotationY = 0;
  let targetRotationX = 0;
  let isFocusing = false; // Si estamos en medio de una animación de enfoque

  function animate() {
    requestAnimationFrame(animate);
    
    const time = performance.now() * 0.001;

    // Efecto pulsante en los marcadores
    spotGroup.children.forEach((obj, i) => {
      // Solo escalar los anillos, no las esferas centrales (opcional)
      if (obj.geometry.type === 'RingGeometry') {
        const s = 1 + 0.3 * Math.sin(time * 3 + i);
        obj.scale.set(s, s, s);
      }
    });

    // Rotación automática suave si no hay selección activa
    if (isAutoRotating && !isFocusing) {
      earthGroup.rotation.y += 0.0005; 
    }

    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  // 9. LÓGICA DE SELECCIÓN (FOCUS PUEBLO)
  const select = document.getElementById("puebloSelect");

  select.addEventListener("change", (e) => {
    const id = e.target.value;
    if (!id) {
      isAutoRotating = true; // Volver a rotar libre
      return;
    }
    
    const p = pueblos[id];
    if (p) focusPueblo(p);
  });

  function focusPueblo(p) {
    isAutoRotating = false;
    isFocusing = true;

    // Calcular ángulos target
    // Longitud: offset de textura. Usually textura empieza en meridiano de Greenwich o similar.
    // ThreeJS esfera: UV mapping hace que 0 este en +Z o -Z dependiendo setup.
    // Ajuste empírico: -lon * deg2rad - PI/2
    
    const latRad = p.lat * (Math.PI / 180);
    const lonRad = p.lon * (Math.PI / 180);

    // Queremos rotar el GRUPO TIERRA (earthGroup) para que el punto (lat,lon) quede mirando a Z+ (donde está la cámara)
    // Rotación Y (Longitud): 
    const targetY = -lonRad + (Math.PI / 2); // Ajuste de fase para centrar
    
    // Rotación X (Latitud):
    const targetX = latRad;

    // Animación suave con GSAP sería ideal, pero haremos interpolación manual simple
    const startY = earthGroup.rotation.y; // Cuidado con vueltas completas
    const startX = earthGroup.rotation.x;
    
    // Resolver el problema de giros de 360 grados (shortest path)
    // Simplificación: reseteamos el modulo de Y para que no de vueltas locas
    const currentY = earthGroup.rotation.y % (Math.PI * 2);
    earthGroup.rotation.y = currentY;

    let diffY = targetY - currentY;
    // Buscar camino más corto
    if (diffY > Math.PI) diffY -= Math.PI * 2;
    if (diffY < -Math.PI) diffY += Math.PI * 2;

    const finalY = currentY + diffY;

    const duration = 1500; // ms
    const startTime = performance.now();

    function tween() {
      const now = performance.now();
      const progress = Math.min(1, (now - startTime) / duration);
      // Easing function (easeInOutCubic)
      const ease = progress < 0.5 ? 4 * progress * progress * progress : 1 - Math.pow(-2 * progress + 2, 3) / 2;

      earthGroup.rotation.y = currentY + (finalY - currentY) * ease;
      earthGroup.rotation.x = startX + (targetX - startX) * ease;

      if (progress < 1) {
        requestAnimationFrame(tween);
      } else {
        isFocusing = false;
      }
    }
    tween();
  }

  // Responsive
  window.addEventListener("resize", () => {
    const w = container.clientWidth;
    const h = container.clientHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
  });

</script>
</body>
</html>
